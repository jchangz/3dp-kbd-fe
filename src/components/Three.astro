---
interface Props {
  type: string;
  keyboard: string;
}

const { type, keyboard } = Astro.props;
---

<section data-type={type} data-keyboard={keyboard} class="canvas col-span-12 row-start-1 h-screen bg-[#1f1f1f]">
  <div class="absolute left-0 top-0 flex h-full w-full items-center justify-center bg-[#f5f5f5] transition-opacity duration-500" id="three-loading">
    <span class="text-black">Loading</span>
  </div>
</section>

<script>
  import * as THREE from "three";
  import { debounce } from "lodash";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
  import { MeshoptDecoder } from "three/examples/jsm/libs/meshopt_decoder.module.js";
  import { GainMapLoader } from "@monogrid/gainmap-js";
  import { GUI } from "three/examples/jsm/libs/lil-gui.module.min.js";
  import { MathUtils } from "three";
  import { three } from "../assets/three.json";

  let canvas: HTMLElement | null, camera: THREE.PerspectiveCamera, scene: THREE.Scene, renderer: THREE.WebGLRenderer, controls: OrbitControls;
  let mx: mxObj[], rows: rowsObj;

  // Group to hold all keycap instanced meshes based on "rows" from json
  const keysGroup = new THREE.Group();
  let switchMesh: THREE.InstancedMesh;
  const switch3DMap = new THREE.Object3D();
  const rotation = Math.PI / 2;

  init();
  animate();

  function init() {
    canvas = document.querySelector(".canvas");
    scene = new THREE.Scene();

    const centerVector = new THREE.Vector3(),
      centerBox = new THREE.Box3();

    const envMapIntensity = 2;

    if (canvas) {
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0x1f1f1f);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
      canvas.appendChild(renderer.domElement);

      camera = new THREE.PerspectiveCamera(1, canvas.offsetWidth / canvas.offsetHeight, 1, 1000);
      camera.position.set(110, 90, -70);
      setCameraFOV();

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      // controls.autoRotate = true;
      controls.minDistance = 100;
      controls.maxDistance = 200;

      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      // Materials

      const caseMat = new THREE.MeshStandardMaterial({
        roughness: 0.8,
        envMapIntensity: envMapIntensity,
      });
      const faceMat = new THREE.MeshStandardMaterial({
        roughness: 0.4,
        envMapIntensity: envMapIntensity,
      });
      const keyMat = new THREE.MeshStandardMaterial({
        color: 0x171718,
        roughness: 0.5,
        envMapIntensity: envMapIntensity,
      });
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x171718,
        roughness: 0.3,
        envMapIntensity: envMapIntensity,
      });
      const pcbMat = new THREE.MeshStandardMaterial({
        color: 0x046307,
        roughness: 0.8,
        envMapIntensity: envMapIntensity,
      });
      const usbMat = new THREE.MeshStandardMaterial({
        metalness: 1,
        roughness: 0.2,
        envMapIntensity: envMapIntensity,
      });
      caseMat.color = faceMat.color = new THREE.Color(0x171718);

      // GUI

      const params = {
        case: caseMat.color.getHex(),
        keycap: keyMat.color.getHex(),
      };

      const gui = new GUI({ autoPlace: false });
      gui.domElement.id = "gui";
      canvas.appendChild(gui.domElement);
      gui.addColor(params, "case").onChange(function (val) {
        caseMat.color.setHex(val);
      });
      gui.addColor(params, "keycap").onChange(function (val) {
        keyMat.color.setHex(val);
      });
      gui.open();

      // Loaders

      const manager = new THREE.LoadingManager(() => {
        const loadScreen = document.getElementById("three-loading");
        loadScreen?.classList.add("opacity-0");
        loadScreen?.addEventListener("transitionend", (e) => {
          if (e.target instanceof HTMLElement) e.target.remove();
        });
        camera.lookAt(centerVector);
        camera.updateProjectionMatrix();
        controls.target.set(centerVector.x, centerVector.y, centerVector.z);
        pmremGenerator.dispose();
      });
      const dracoLoader = new DRACOLoader(manager);
      dracoLoader.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.7/");
      const loader = new GLTFLoader(manager).setDRACOLoader(dracoLoader).setMeshoptDecoder(MeshoptDecoder);

      // Textures

      const texloader = new THREE.TextureLoader(manager);

      const caseNormal = texloader.load("models/3dp_normal.webp");
      caseNormal.repeat.set(0, 3);
      caseMat.normalMap = caseNormal;

      const caseRoughness = texloader.load("models/3dp_roughness.webp");
      caseRoughness.repeat.set(0, 3);
      caseMat.roughnessMap = caseRoughness;

      const caseAO = texloader.load("models/3dp_ao.webp");
      caseAO.repeat.set(0, 3);
      caseMat.aoMap = caseAO;

      const caseFaceNormal = texloader.load("models/3dp_face.webp");
      caseFaceNormal.repeat.set(25, 25);
      faceMat.normalMap = caseFaceNormal;

      const keyNormal = texloader.load("models/key_normal.webp");
      keyNormal.repeat.set(2, 2);
      keyMat.normalMap = keyNormal;

      const keyRoughness = texloader.load("models/key_roughness.webp");
      keyRoughness.repeat.set(2, 2);
      keyMat.roughnessMap = keyRoughness;

      caseNormal.wrapS = caseNormal.wrapT = caseRoughness.wrapS = caseRoughness.wrapT = caseAO.wrapS = caseAO.wrapT = caseFaceNormal.wrapS = caseFaceNormal.wrapT = keyNormal.wrapS = keyNormal.wrapT = keyRoughness.wrapS = keyRoughness.wrapT = THREE.RepeatWrapping;

      // Environment

      const gainMap = new GainMapLoader(renderer).load(["gainmap/studio.webp", "gainmap/studio-gainmap.webp", "gainmap/studio.json"], function (texture) {
        const gainMapBackground = texture.renderTarget.texture;
        gainMapBackground.mapping = THREE.EquirectangularReflectionMapping;
        gainMapBackground.needsUpdate = true;
        const gainMapPMREMRenderTarget = pmremGenerator.fromEquirectangular(gainMapBackground);

        caseMat.envMap = faceMat.envMap = usbMat.envMap = pcbMat.envMap = keyMat.envMap = baseMat.envMap = gainMapPMREMRenderTarget ? gainMapPMREMRenderTarget.texture : null;
        gainMap.dispose();
      });

      // Lights

      const keyLight = new THREE.DirectionalLight(0xffffff, 1);
      keyLight.position.set(-5, 4, 2);
      scene.add(keyLight);

      const keyLight2 = new THREE.DirectionalLight(0xffffff, 1);
      keyLight2.position.set(-2, 4, -2);
      keyLight2.castShadow = true;
      keyLight2.shadow.mapSize.width = 1024;
      keyLight2.shadow.mapSize.height = 1024;
      scene.add(keyLight2);

      // Shadow Plane

      const planeGeometry = new THREE.PlaneGeometry(2, 5);
      planeGeometry.rotateX(-Math.PI / 2);
      const shadowMaterial = new THREE.ShadowMaterial();
      shadowMaterial.opacity = 0.3;
      const shadowPlane = new THREE.Mesh(planeGeometry, shadowMaterial);
      shadowPlane.receiveShadow = true;
      scene.add(shadowPlane);

      // Load Models

      const keyboardName = canvas.dataset.keyboard || "";
      ({ mx, rows } = (three as threeObj)[keyboardName]);
      const keyboardModelSrc = `/models/${keyboardName}.glb`;
      const caseModelSrc = `/models/t${canvas.dataset.type}-${keyboardName.slice(0, 1)}.glb`;

      loader.load(caseModelSrc, function (gltf) {
        gltf.scene.traverse((child) => {
          if (child.name === "Scene") {
            child.rotation.y = rotation;
            centerBox.setFromObject(child);
            centerBox.getCenter(centerVector);
          }
          if (child instanceof THREE.Mesh && child.isMesh) {
            if (child.name.includes("_1")) child.material = caseMat;
            else child.material = faceMat;
          }
          child.castShadow = true;
        });
        scene.add(gltf.scene);
      });
      loader.load(keyboardModelSrc, function (gltf) {
        gltf.scene.traverse((child) => {
          if (child instanceof THREE.Mesh && child.isMesh) {
            child.material = keyMat;
            if (child.name === "plate" || child.name === "switch") child.material = baseMat;
            if (child.name === "pcb") child.material = pcbMat;
            if (child.name === "usb") child.material = usbMat;
          }
        });
        gltf.scene.rotation.y = rotation;
        scene.add(switchMesh, keysGroup, gltf.scene);
      });

      loader.load("models/switch.glb", function (gltf) {
        // Create instanced mesh for all keycaps
        Object.keys(rows).forEach((row) => {
          const _keycapMesh = gltf.scene.getObjectByName(row);
          if (_keycapMesh && _keycapMesh instanceof THREE.Mesh) {
            const keycapMesh = new THREE.InstancedMesh(_keycapMesh.geometry.clone(), keyMat, rows[row].length);
            keycapMesh.name = row;
            keycapMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            keysGroup.add(keycapMesh);
          }
        });

        // Create instanced mesh for mx switch
        const _switchMesh = gltf.scene.getObjectByName("switch");
        if (_switchMesh instanceof THREE.Mesh) {
          switchMesh = new THREE.InstancedMesh(_switchMesh.geometry.clone(), baseMat, mx.length);
          switchMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        }

        switchMesh.rotation.y = keysGroup.rotation.y = rotation;
        scene.add(switchMesh, keysGroup);
      });

      // Resize Handler

      const debounceResize = debounce(onWindowResize, 250);
      window.addEventListener("resize", debounceResize);
    }
  }

  function setCameraFOV() {
    // https://discourse.threejs.org/t/keeping-an-object-scaled-based-on-the-bounds-of-the-canvas-really-battling-to-explain-this-one/17574/10
    const fov = 1;
    const aspectRatio = 2;
    const cameraHeight = Math.tan(MathUtils.degToRad(fov / 2));
    const ratio = camera.aspect / aspectRatio;
    const newCameraHeight = cameraHeight / ratio;
    camera.fov = MathUtils.radToDeg(Math.atan(newCameraHeight)) * 2;
  }

  function onWindowResize() {
    if (canvas) {
      const width = canvas.offsetWidth;
      const height = canvas.offsetHeight;
      camera.aspect = width / height;

      setCameraFOV();

      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    render();
  }

  function render() {
    if (switchMesh) {
      let i = 0;
      for (let x = 0; x < mx.length; x++) {
        switch3DMap.position.set(mx[i].x, mx[i].y, mx[i].z);
        switch3DMap.updateMatrix();

        keysGroup.children.forEach((mesh) => {
          if (mesh instanceof THREE.InstancedMesh && rows[mesh.name].matrix[i]) {
            mesh.setMatrixAt(rows[mesh.name].matrix[i] - 1, switch3DMap.matrix);
          }
        });
        switchMesh.setMatrixAt(i++, switch3DMap.matrix);
      }
      switchMesh.instanceMatrix.needsUpdate = true;
    }
    controls.update();
    renderer.render(scene, camera);
  }
</script>

<style is:global>
  #gui {
    position: absolute;
    bottom: 1rem;
    left: 1rem;
  }
</style>
