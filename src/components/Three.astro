---
interface Props {
  type: string;
  keyboard: string;
}

const { type, keyboard } = Astro.props;
---

<section
  data-type={type}
  data-keyboard={keyboard}
  class="canvas relative col-span-9 col-start-4 aspect-[2] overflow-hidden bg-black 2xl:aspect-[2.5]"
>
  <div
    class="absolute left-0 top-0 flex h-full w-full items-center justify-center bg-black transition-opacity duration-500"
    id="three-loading"
  >
    <span class="text-white">Loading</span>
  </div>
</section>

<script>
  import * as THREE from "three";
  import { throttle } from "lodash";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { EXRLoader } from "three/addons/loaders/EXRLoader.js";
  import { three } from "../assets/three.json";

  let canvas: HTMLElement | null;

  let camera: THREE.PerspectiveCamera,
    scene: THREE.Scene,
    renderer: THREE.WebGLRenderer;

  interface mxObj {
    x: number[];
    y: number[];
    z: number[];
  }
  interface rowsObj {
    [key: string]: { length: number; matrix: number[] };
  }
  interface threeObj {
    [index: string]: {
      mx: mxObj;
      rows: rowsObj;
    };
  }

  let mx: mxObj, rows: rowsObj;

  // Group to hold all keycap instanced meshes based on "rows" from json
  const keysGroup = new THREE.Group();
  let switchMesh: THREE.InstancedMesh;

  const switch3DMap = new THREE.Object3D();

  init();
  animate();

  function init() {
    canvas = document.querySelector(".canvas");
    scene = new THREE.Scene();

    if (canvas) {
      camera = new THREE.PerspectiveCamera(
        1,
        canvas.offsetWidth / canvas.offsetHeight,
        1,
        1000,
      );
      camera.position.set(0, 60, 120);
      camera.updateProjectionMatrix();

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);

      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      const keyboardName = canvas.dataset.keyboard || "";

      ({ mx, rows } = (three as threeObj)[keyboardName]);

      const keyboardModelSrc = `/models/${keyboardName}.glb`;
      const caseModelSrc = `/models/t${canvas.dataset.type}-${keyboardName.slice(0, 1)}.glb`;

      const keyMaterial = new THREE.MeshStandardMaterial({
        color: 0x010101,
        roughness: 0.3,
      });
      const usbMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 1,
        roughness: 0.25,
      });
      const caseMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.1,
      });

      const manager = new THREE.LoadingManager(() => {
        const loadScreen = document.getElementById("three-loading");
        loadScreen?.classList.add("opacity-0");
        loadScreen?.addEventListener("transitionend", (e) => {
          if (e.target instanceof HTMLElement) {
            e.target.remove();
          }
        });
        pmremGenerator.dispose();
      });

      new EXRLoader(manager).load("studio.exr", function (texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        const exrRenderTarget = pmremGenerator.fromEquirectangular(texture);
        caseMaterial.envMap = exrRenderTarget ? exrRenderTarget.texture : null;
        caseMaterial.envMapIntensity = 0.1;
        usbMaterial.envMap = exrRenderTarget ? exrRenderTarget.texture : null;
        usbMaterial.envMapIntensity - 0.1;
        keyMaterial.envMap = exrRenderTarget ? exrRenderTarget.texture : null;
        keyMaterial.envMapIntensity = 0.1;
      });

      const loader = new GLTFLoader(manager);
      loader.load(caseModelSrc, function (gltf) {
        gltf.scene.traverse((child) => {
          if (child instanceof THREE.Mesh && child.isMesh) {
            child.material = caseMaterial;
          }
        });
        scene.add(gltf.scene);
      });
      loader.load(keyboardModelSrc, function (gltf) {
        // Create instanced mesh for all keycaps
        Object.keys(rows).forEach((row) => {
          const _keycapMesh = gltf.scene.getObjectByName(row);
          if (_keycapMesh && _keycapMesh instanceof THREE.Mesh) {
            // Hide all original keycap meshes expect r1
            if (row !== "r1") _keycapMesh.visible = false;

            const keycapMesh = new THREE.InstancedMesh(
              _keycapMesh.geometry.clone(),
              keyMaterial,
              rows[row].length,
            );
            keycapMesh.name = row;
            keycapMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            keysGroup.add(keycapMesh);
          }
        });

        // Create instanced mesh for mx switch
        const _switchMesh = gltf.scene.getObjectByName("switch");
        if (_switchMesh instanceof THREE.Mesh) {
          switchMesh = new THREE.InstancedMesh(
            _switchMesh.geometry.clone(),
            keyMaterial,
            mx.x.length,
          );
          switchMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        }

        gltf.scene.traverse((child) => {
          if (child instanceof THREE.Mesh && child.isMesh) {
            child.material = keyMaterial;
            if (child.name === "usb") child.material = usbMaterial;
          }
        });

        scene.add(switchMesh, keysGroup, gltf.scene);
      });

      canvas.appendChild(renderer.domElement);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
      directionalLight.position.set(5, 1, -2);
      const overheadLight = new THREE.DirectionalLight(0xffffff, 2);
      overheadLight.position.set(-0.5, 3, -5);
      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 2);
      directionalLight2.position.set(-3, 1, 0);
      scene.add(overheadLight);
      scene.add(directionalLight);
      scene.add(directionalLight2);

      new OrbitControls(camera, renderer.domElement);

      const throttleResize = throttle(onWindowResize, 500);
      window.addEventListener("resize", throttleResize);
    }
  }

  function onWindowResize() {
    if (canvas) {
      const width = canvas.offsetWidth;
      const height = canvas.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    render();
  }

  function render() {
    if (switchMesh) {
      let i = 0;
      for (let x = 0; x < mx.x.length; x++) {
        switch3DMap.position.set(mx.x[i], mx.y[i], mx.z[i]);
        switch3DMap.updateMatrix();

        keysGroup.children.forEach((mesh) => {
          if (
            mesh instanceof THREE.InstancedMesh &&
            rows[mesh.name].matrix[i]
          ) {
            mesh.setMatrixAt(rows[mesh.name].matrix[i] - 1, switch3DMap.matrix);
          }
        });
        switchMesh.setMatrixAt(i++, switch3DMap.matrix);
      }
      switchMesh.instanceMatrix.needsUpdate = true;
    }
    renderer.render(scene, camera);
  }
</script>
