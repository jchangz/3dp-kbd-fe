---
interface Props {
  type: string;
  keyboard: string;
}

const { type, keyboard } = Astro.props;
---

<section
  data-type={type}
  data-keyboard={keyboard}
  class="canvas relative col-span-9 col-start-4 aspect-[2] overflow-hidden bg-black 2xl:aspect-[2.5]"
>
  <div
    class="absolute left-0 top-0 flex h-full w-full items-center justify-center bg-black transition-opacity duration-500"
    id="three-loading"
  >
    <span class="text-white">Loading</span>
  </div>
</section>

<script>
  import * as THREE from "three";
  import { throttle } from "lodash";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { EXRLoader } from "three/addons/loaders/EXRLoader.js";
  import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
  import { MeshoptDecoder } from "three/examples/jsm/libs/meshopt_decoder.module.js";
  import { three } from "../assets/three.json";

  let canvas: HTMLElement | null,
    camera: THREE.PerspectiveCamera,
    scene: THREE.Scene,
    renderer: THREE.WebGLRenderer,
    controls: OrbitControls;

  const centerVector = new THREE.Vector3(),
    centerBox = new THREE.Box3();

  interface mxObj {
    x: number[];
    y: number[];
    z: number[];
  }
  interface rowsObj {
    [key: string]: { length: number; matrix: number[] };
  }
  interface threeObj {
    [index: string]: {
      mx: mxObj;
      rows: rowsObj;
    };
  }

  let mx: mxObj, rows: rowsObj;

  // Group to hold all keycap instanced meshes based on "rows" from json
  const keysGroup = new THREE.Group();
  let switchMesh: THREE.InstancedMesh;

  const switch3DMap = new THREE.Object3D();

  init();
  animate();

  function init() {
    canvas = document.querySelector(".canvas");
    scene = new THREE.Scene();

    if (canvas) {
      camera = new THREE.PerspectiveCamera(
        1,
        canvas.offsetWidth / canvas.offsetHeight,
        1,
        1000,
      );
      camera.position.set(0, 60, 120);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.setClearColor(0xf5f5f5);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);

      const pmremGenerator = new THREE.PMREMGenerator(renderer);
      pmremGenerator.compileEquirectangularShader();

      controls = new OrbitControls(camera, renderer.domElement);

      const keyboardName = canvas.dataset.keyboard || "";

      ({ mx, rows } = (three as threeObj)[keyboardName]);

      const keyboardModelSrc = `/models/${keyboardName}.glb`;
      const caseModelSrc = `/models/t${canvas.dataset.type}-${keyboardName.slice(0, 1)}.glb`;

      const manager = new THREE.LoadingManager(() => {
        const loadScreen = document.getElementById("three-loading");
        loadScreen?.classList.add("opacity-0");
        loadScreen?.addEventListener("transitionend", (e) => {
          if (e.target instanceof HTMLElement) {
            e.target.remove();
          }
        });
        camera.lookAt(centerVector);
        camera.updateProjectionMatrix();
        controls.target.set(centerVector.x, centerVector.y, centerVector.z);
        pmremGenerator.dispose();
      });

      const texloader = new THREE.TextureLoader(manager);

      const caseTexNormal = texloader.load("models/3dp_normal.webp");
      const caseTexRoughness = texloader.load("models/3dp_roughness.webp");
      const caseTexAO = texloader.load("models/3dp_ao.webp");
      const caseFaceNormal = texloader.load("models/3dp_face.webp");
      const keycapNormal = texloader.load("models/key_normal.webp");
      const keycapRoughness = texloader.load("models/key_roughness.webp");

      caseTexNormal.repeat.set(0, 3);
      caseTexRoughness.repeat.set(0, 3);
      caseTexAO.repeat.set(0, 3);
      caseFaceNormal.repeat.set(25, 25);
      keycapNormal.repeat.set(2, 2);
      keycapRoughness.repeat.set(2, 2);

      caseTexNormal.wrapS =
        caseTexNormal.wrapT =
        caseTexRoughness.wrapS =
        caseTexRoughness.wrapT =
        caseTexAO.wrapS =
        caseTexAO.wrapT =
        caseFaceNormal.wrapS =
        caseFaceNormal.wrapT =
        keycapNormal.wrapS =
        keycapNormal.wrapT =
        keycapRoughness.wrapS =
        keycapRoughness.wrapT =
          THREE.RepeatWrapping;

      const envMapIntensity = 1;

      const caseMaterial = new THREE.MeshStandardMaterial({
        roughness: 0.2,
        envMapIntensity: envMapIntensity,
        normalMap: caseTexNormal,
        roughnessMap: caseTexRoughness,
        aoMap: caseTexAO,
      });
      const faceMaterial = new THREE.MeshStandardMaterial({
        roughness: 0.2,
        normalMap: caseFaceNormal,
        envMapIntensity: envMapIntensity,
      });

      const keyMaterial = new THREE.MeshStandardMaterial({
        color: 0x171718,
        roughness: 0.4,
        normalMap: keycapNormal,
        roughnessMap: keycapRoughness,
        envMapIntensity: envMapIntensity,
      });
      const usbMaterial = new THREE.MeshStandardMaterial({
        metalness: 1,
        roughness: 0.25,
        envMapIntensity: envMapIntensity,
      });

      caseMaterial.color = faceMaterial.color = new THREE.Color(0xfefefe);

      new EXRLoader(manager).load("studio.exr", function (texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        const exrRenderTarget = pmremGenerator.fromEquirectangular(texture);
        caseMaterial.envMap =
          faceMaterial.envMap =
          usbMaterial.envMap =
          keyMaterial.envMap =
            exrRenderTarget ? exrRenderTarget.texture : null;
      });

      const dracoLoader = new DRACOLoader(manager);
      dracoLoader.setDecoderPath(
        "https://www.gstatic.com/draco/versioned/decoders/1.5.7/",
      );

      const loader = new GLTFLoader(manager)
        .setDRACOLoader(dracoLoader)
        .setMeshoptDecoder(MeshoptDecoder);

      loader.load(caseModelSrc, function (gltf) {
        gltf.scene.traverse((child) => {
          if (child.name === "Scene") {
            centerBox.setFromObject(child);
            centerBox.getCenter(centerVector);
          }
          if (child instanceof THREE.Mesh && child.isMesh) {
            if (child.name.includes("_1")) child.material = caseMaterial;
            else child.material = faceMaterial;
          }
          child.castShadow = true;
        });
        scene.add(gltf.scene);
      });
      loader.load(keyboardModelSrc, function (gltf) {
        // Create instanced mesh for all keycaps
        Object.keys(rows).forEach((row) => {
          const _keycapMesh = gltf.scene.getObjectByName(row);
          if (_keycapMesh && _keycapMesh instanceof THREE.Mesh) {
            // Hide all original keycap meshes expect r1
            if (row !== "r1") _keycapMesh.visible = false;

            const keycapMesh = new THREE.InstancedMesh(
              _keycapMesh.geometry.clone(),
              keyMaterial,
              rows[row].length,
            );
            keycapMesh.name = row;
            keycapMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            keysGroup.add(keycapMesh);
          }
        });

        // Create instanced mesh for mx switch
        const _switchMesh = gltf.scene.getObjectByName("switch");
        if (_switchMesh instanceof THREE.Mesh) {
          switchMesh = new THREE.InstancedMesh(
            _switchMesh.geometry.clone(),
            keyMaterial,
            mx.x.length,
          );
          switchMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        }

        gltf.scene.traverse((child) => {
          if (child instanceof THREE.Mesh && child.isMesh) {
            child.material = keyMaterial;
            if (child.name === "usb") child.material = usbMaterial;
          }
        });

        scene.add(switchMesh, keysGroup, gltf.scene);
      });

      canvas.appendChild(renderer.domElement);

      // shadow plane
      const planeGeometry = new THREE.PlaneGeometry(5, 2);
      planeGeometry.rotateX(-Math.PI / 2);
      const shadowMaterial = new THREE.ShadowMaterial();
      shadowMaterial.opacity = 0.5;
      const shadowPlane = new THREE.Mesh(planeGeometry, shadowMaterial);
      shadowPlane.receiveShadow = true;
      scene.add(shadowPlane);

      // main light
      const keyLight = new THREE.DirectionalLight(0xffffff, 1);
      keyLight.position.set(-2, 6, 2);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.width = 1024;
      keyLight.shadow.mapSize.height = 1024;
      keyLight.shadow.camera.near = 5;
      keyLight.shadow.camera.far = 8;
      keyLight.shadow.camera.left = -2;
      keyLight.shadow.camera.right = 2.2;
      keyLight.shadow.camera.top = 2;
      keyLight.shadow.camera.bottom = -2;
      scene.add(keyLight);

      // fill light
      const fillLight = new THREE.DirectionalLight(0xffffff, 1);
      fillLight.position.set(-2, 6, -12);
      scene.add(fillLight);

      const throttleResize = throttle(onWindowResize, 500);
      window.addEventListener("resize", throttleResize);
    }
  }

  function onWindowResize() {
    if (canvas) {
      const width = canvas.offsetWidth;
      const height = canvas.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    render();
  }

  function render() {
    if (switchMesh) {
      let i = 0;
      for (let x = 0; x < mx.x.length; x++) {
        switch3DMap.position.set(mx.x[i], mx.y[i], mx.z[i]);
        switch3DMap.updateMatrix();

        keysGroup.children.forEach((mesh) => {
          if (
            mesh instanceof THREE.InstancedMesh &&
            rows[mesh.name].matrix[i]
          ) {
            mesh.setMatrixAt(rows[mesh.name].matrix[i] - 1, switch3DMap.matrix);
          }
        });
        switchMesh.setMatrixAt(i++, switch3DMap.matrix);
      }
      switchMesh.instanceMatrix.needsUpdate = true;
    }
    renderer.render(scene, camera);
  }
</script>
