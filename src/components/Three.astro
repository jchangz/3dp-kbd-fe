---
interface Props {
  type: string;
  keyboard: string;
}

const { type, keyboard } = Astro.props;
---

<section
  data-type={type}
  data-keyboard={keyboard}
  class="canvas col-span-9 col-start-4 aspect-[2] overflow-hidden 2xl:aspect-[2.5]"
>
</section>

<script>
  import * as THREE from "three";
  import { throttle } from "lodash";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { src, three } from "../assets/models/data.json";

  const canvas: HTMLElement | null = document.querySelector(".canvas");
  const scene = new THREE.Scene();
  const renderer = new THREE.WebGLRenderer();
  let camera: THREE.OrthographicCamera;

  let data: {
    mx: { x: number[]; y: number[]; z: number[] };
    rows: { [key: string]: { length: number; matrix: number[] } };
  } = {
    mx: { x: [0], y: [0], z: [0] },
    rows: { r1: { length: 1, matrix: [0] } },
  };
  interface threeObj {
    [index: string]: typeof data;
  }
  interface srcObj {
    [index: string]: {
      keyboardModel: string;
      caseModel: { [index: string]: string };
    };
  }

  let keyboardModelSrc = "",
    caseModelSrc = "";

  if (canvas) {
    renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
    canvas.appendChild(renderer.domElement);
    camera = new THREE.OrthographicCamera(
      canvas.offsetWidth / -2,
      canvas.offsetWidth / 2,
      canvas.offsetHeight / 2,
      canvas.offsetHeight / -2,
      1,
      1000,
    );
    camera.zoom = 200;
    camera.position.z = 5;
    camera.updateProjectionMatrix();
    const controls = new OrbitControls(camera, renderer.domElement);

    const keyboardName: string = canvas.dataset.keyboard || "quefrency";
    data = (three as threeObj)[keyboardName];

    const srcData = (src as srcObj)[keyboardName];
    keyboardModelSrc = srcData.keyboardModel;
    caseModelSrc = srcData.caseModel[canvas.dataset.type || "1"];
  }

  const keyMaterial = new THREE.MeshStandardMaterial({
    color: 0x010101,
    roughness: 0.3,
  });
  const usbMaterial = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    metalness: 1,
    roughness: 0.25,
  });
  const caseMaterial = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.3,
  });

  const { mx, rows } = data;

  // Group to hold all keycap instanced meshes based on "rows" from json
  const keysGroup = new THREE.Group();

  let switchGeometry, stemMesh: THREE.InstancedMesh;

  const dummy = new THREE.Object3D();
  const loader = new GLTFLoader();

  loader.load(caseModelSrc, function (gltf) {
    scene.add(gltf.scene);
    gltf.scene.traverse((child) => {
      if ((child as THREE.Mesh).isMesh)
        (child as THREE.Mesh).material = caseMaterial;
    });
  });

  loader.load(
    keyboardModelSrc,
    function (gltf) {
      // Create instanced mesh for all keycaps
      Object.keys(rows).forEach((row) => {
        const mesh = gltf.scene.getObjectByName(row) as THREE.Mesh;

        // Hide all original keycap meshes expect r1
        if (row !== "r1") mesh.visible = false;

        const rowMesh = new THREE.InstancedMesh(
          mesh.geometry.clone(),
          keyMaterial,
          rows[row].length,
        );
        rowMesh.name = row;
        rowMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

        keysGroup.add(rowMesh);
      });

      // Create instanced mesh for mx switch
      const _switchMesh = gltf.scene.getObjectByName("switch") as THREE.Mesh;
      switchGeometry = _switchMesh.geometry.clone();
      stemMesh = new THREE.InstancedMesh(
        switchGeometry,
        keyMaterial,
        mx.x.length,
      );
      stemMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      // Add all meshes to the scene
      scene.add(stemMesh);
      scene.add(keysGroup);
      scene.add(gltf.scene);

      gltf.scene.traverse((child) => {
        const childMesh = child as THREE.Mesh;
        if (childMesh.isMesh) childMesh.material = keyMaterial;
        if (child.name === "usb") childMesh.material = usbMaterial;
      });
    },
    function (xhr) {
      console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
    },
    function (error) {
      console.log("An error happened", error);
    },
  );

  const ambientLight = new THREE.AmbientLight(0x404040);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(1, 1, -2);
  const directionalLight2 = new THREE.DirectionalLight(0xffffff, 5);
  directionalLight2.position.set(-3, 1, 0);
  const helper = new THREE.DirectionalLightHelper(directionalLight);
  const helper2 = new THREE.DirectionalLightHelper(directionalLight2);
  // scene.add(helper);
  // scene.add(helper2);
  scene.add(ambientLight);
  scene.add(directionalLight);
  scene.add(directionalLight2);

  function resize() {
    if (canvas) {
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
    }
  }
  const throttleResize = throttle(resize, 500);
  window.addEventListener("resize", throttleResize);

  function animate() {
    requestAnimationFrame(animate);
    if (stemMesh) {
      let i = 0;
      for (let x = 0; x < mx.x.length; x++) {
        dummy.position.set(mx.x[i], mx.y[i], mx.z[i]);
        dummy.updateMatrix();

        keysGroup.children.forEach((mesh) => {
          if (rows[mesh.name].matrix[i]) {
            (mesh as THREE.InstancedMesh).setMatrixAt(
              rows[mesh.name].matrix[i] - 1,
              dummy.matrix,
            );
          }
        });
        stemMesh.setMatrixAt(i++, dummy.matrix);
      }
      stemMesh.instanceMatrix.needsUpdate = true;
    }
    renderer.render(scene, camera);
  }

  animate();
</script>
