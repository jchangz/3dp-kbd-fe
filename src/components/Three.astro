---
interface Props {
  type: string;
  keyboard: string;
}

const { type, keyboard } = Astro.props;
---

<section
  data-type={type}
  data-keyboard={keyboard}
  class="canvas col-span-9 col-start-4 aspect-[2] overflow-hidden bg-black 2xl:aspect-[2.5]"
>
</section>

<script>
  import * as THREE from "three";
  import { throttle } from "lodash";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { three } from "../assets/models/data.json";

  let canvas: HTMLElement | null;

  let camera: THREE.PerspectiveCamera,
    scene: THREE.Scene,
    renderer: THREE.WebGLRenderer;

  interface mxObj {
    x: number[];
    y: number[];
    z: number[];
  }
  interface rowsObj {
    [key: string]: { length: number; matrix: number[] };
  }
  interface threeObj {
    [index: string]: {
      mx: mxObj;
      rows: rowsObj;
    };
  }

  let mx: mxObj, rows: rowsObj;

  // Group to hold all keycap instanced meshes based on "rows" from json
  const keysGroup = new THREE.Group();
  let switchMesh: THREE.InstancedMesh;

  const switch3DMap = new THREE.Object3D();

  init();
  animate();

  function init() {
    canvas = document.querySelector(".canvas");
    scene = new THREE.Scene();

    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, -2);
    scene.add(directionalLight);
    const directionalLight2 = new THREE.DirectionalLight(0xffffff, 5);
    directionalLight2.position.set(-3, 1, 0);
    scene.add(directionalLight2);

    if (canvas) {
      camera = new THREE.PerspectiveCamera(
        1,
        canvas.offsetWidth / canvas.offsetHeight,
        1,
        1000,
      );
      camera.position.set(0, 100, 100);
      camera.updateProjectionMatrix();

      const keyboardName = canvas.dataset.keyboard || "";

      ({ mx, rows } = (three as threeObj)[keyboardName]);

      const keyboardModelSrc = `src/assets/models/${keyboardName}.glb`;
      const caseModelSrc = `src/assets/models/t${canvas.dataset.type}-${keyboardName.slice(0, 1)}.glb`;

      const keyMaterial = new THREE.MeshStandardMaterial({
        color: 0x010101,
        roughness: 0.3,
      });
      const usbMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 1,
        roughness: 0.25,
      });
      const caseMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.3,
      });

      const loader = new GLTFLoader();
      loader.load(caseModelSrc, function (gltf) {
        gltf.scene.traverse((child) => {
          if (child instanceof THREE.Mesh && child.isMesh) {
            child.material = caseMaterial;
          }
        });
        scene.add(gltf.scene);
      });
      loader.load(keyboardModelSrc, function (gltf) {
        // Create instanced mesh for all keycaps
        Object.keys(rows).forEach((row) => {
          const _keycapMesh = gltf.scene.getObjectByName(row);
          if (_keycapMesh && _keycapMesh instanceof THREE.Mesh) {
            // Hide all original keycap meshes expect r1
            if (row !== "r1") _keycapMesh.visible = false;

            const keycapMesh = new THREE.InstancedMesh(
              _keycapMesh.geometry.clone(),
              keyMaterial,
              rows[row].length,
            );
            keycapMesh.name = row;
            keycapMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            keysGroup.add(keycapMesh);
          }
        });

        // Create instanced mesh for mx switch
        const _switchMesh = gltf.scene.getObjectByName("switch");
        if (_switchMesh instanceof THREE.Mesh) {
          switchMesh = new THREE.InstancedMesh(
            _switchMesh.geometry.clone(),
            keyMaterial,
            mx.x.length,
          );
          switchMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        }

        gltf.scene.traverse((child) => {
          if (child instanceof THREE.Mesh && child.isMesh) {
            child.material = keyMaterial;
            if (child.name === "usb") child.material = usbMaterial;
          }
        });

        scene.add(switchMesh, keysGroup, gltf.scene);
      });

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
      canvas.appendChild(renderer.domElement);

      new OrbitControls(camera, renderer.domElement);

      const throttleResize = throttle(onWindowResize, 500);
      window.addEventListener("resize", throttleResize);
    }
  }

  function onWindowResize() {
    if (canvas) {
      const width = canvas.offsetWidth;
      const height = canvas.offsetHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
    }
  }

  function animate() {
    requestAnimationFrame(animate);
    render();
  }

  function render() {
    if (switchMesh) {
      let i = 0;
      for (let x = 0; x < mx.x.length; x++) {
        switch3DMap.position.set(mx.x[i], mx.y[i], mx.z[i]);
        switch3DMap.updateMatrix();

        keysGroup.children.forEach((mesh) => {
          if (
            mesh instanceof THREE.InstancedMesh &&
            rows[mesh.name].matrix[i]
          ) {
            mesh.setMatrixAt(rows[mesh.name].matrix[i] - 1, switch3DMap.matrix);
          }
        });
        switchMesh.setMatrixAt(i++, switch3DMap.matrix);
      }
      switchMesh.instanceMatrix.needsUpdate = true;
    }
    renderer.render(scene, camera);
  }
</script>
